<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>2</storyId>
    <title>Configure PostgreSQL Database with Prisma ORM</title>
    <status>drafted</status>
    <generatedAt>2025-11-06</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/1-2-configure-postgresql-database-with-prisma-orm.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>PostgreSQL database configured with Prisma ORM</iWant>
    <soThat>the application can persist user data and content</soThat>
    <tasks>
- [ ] **Task 1: Install and configure Prisma** (AC: #1)
  - [ ] Install Prisma dependencies (`@prisma/client`, `prisma` dev dependency)
  - [ ] Initialize Prisma in the project structure (`apps/web/prisma/`)
  - [ ] Configure `prisma/schema.prisma` with PostgreSQL provider
  - [ ] Set up database URL in `.env.local` and create `.env.example` template

- [ ] **Task 2: Create initial database schema with User model** (AC: #1, #2)
  - [ ] Define User model in `schema.prisma` with proper fields
  - [ ] Follow naming conventions from architecture: snake_case for table/column names

- [ ] **Task 3: Set up cloud PostgreSQL database** (AC: #3)
  - [ ] Create PostgreSQL database on Vercel Postgres or Neon
  - [ ] Configure connection pooling for serverless environment
  - [ ] Update `DATABASE_URL` environment variable with connection string
  - [ ] Test connection to cloud database

- [ ] **Task 4: Generate Prisma Client and apply schema** (AC: #4)
  - [ ] Run `pnpm prisma generate` to generate Prisma Client
  - [ ] Run `pnpm prisma db push` to apply schema to database
  - [ ] Verify tables are created in database (use Prisma Studio or database GUI)
  - [ ] Add Prisma commands to `package.json` scripts

- [ ] **Task 5: Create Prisma client singleton** (AC: #1)
  - [ ] Create `src/lib/prisma.ts` file
  - [ ] Implement singleton pattern for Prisma Client (prevents connection exhaustion in dev)
  - [ ] Export configured Prisma client for use in API routes

- [ ] **Task 6: Implement health check API endpoint** (AC: #5)
  - [ ] Create `/api/health/route.ts` API route handler
  - [ ] Test database connection using `prisma.$queryRaw` or simple query
  - [ ] Return standardized response format
  - [ ] Handle connection errors and return appropriate error response

- [ ] **Task 7: Testing** (All ACs)
  - [ ] Test `prisma generate` command execution
  - [ ] Test `prisma db push` command execution
  - [ ] Test `/api/health` endpoint returns successful response
  - [ ] Test database operations (basic CRUD on User model)
  - [ ] Verify Prisma Studio can connect and view data</tasks>
  </story>

  <acceptanceCriteria>
1. **Given** the monorepo from Story 1.1
   **When** database configuration is complete
   **Then** Prisma is installed and configured in packages/database

2. **And** database schema includes initial User model with proper fields (id, email, password_hash, created_at, updated_at)

3. **And** connection to PostgreSQL (Vercel Postgres or Neon) is verified and working

4. **And** `prisma generate` and `prisma db push` commands execute successfully

5. **And** a health check API endpoint (`/api/health`) confirms database connectivity and returns proper status</acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Data Architecture</section>
        <snippet>Core User model with id (cuid), email (unique), password_hash, created_at, updated_at fields. Database uses PostgreSQL via Vercel Postgres with Prisma 5.x ORM.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Database Patterns</section>
        <snippet>Tables use snake_case plural naming (users), columns use snake_case (user_id, created_at), foreign keys follow {table}_id format.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>API Patterns</section>
        <snippet>Standard response format with success: true/false, data or error object. Error codes follow DOMAIN_ACTION_ERROR format.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Story 1.2: Configure PostgreSQL Database with Prisma ORM</section>
        <snippet>Database configuration story with Prisma ORM setup, User model creation, and health check endpoint implementation. Uses Vercel Postgres or Neon for cloud database.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>Technical Assumptions</section>
        <snippet>PostgreSQL database for data persistence, Prisma ORM for type-safe database access, Vercel hosting with serverless functions.</snippet>
      </doc>
    </docs>
    <code>
      <!-- No existing code artifacts yet as this is the second story in a new project -->
    </code>
    <dependencies>
      <node>
        <dependency name="@prisma/client" version="^5.x" />
        <dependency name="prisma" version="^5.x" devDependency="true" />
        <dependency name="@types/node" version="^20.x" devDependency="true" />
      </node>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>Database must use PostgreSQL (Vercel Postgres or Neon) for serverless compatibility</constraint>
    <constraint>Connection pooling is required for serverless functions to prevent connection exhaustion</constraint>
    <constraint>Prisma client must use singleton pattern in src/lib/prisma.ts</constraint>
    <constraint>Database naming must follow snake_case for tables and columns</constraint>
    <constraint>TypeScript models use PascalCase while database uses snake_case</constraint>
    <constraint>All API responses must follow standard success/error format</constraint>
    <constraint>Health check endpoint must verify actual database connectivity</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>Health Check API</name>
      <kind>REST endpoint</kind>
      <signature>GET /api/health</signature>
      <path>src/app/api/health/route.ts</path>
      <response>{ success: true, data: { status: "ok", database: "connected" } }</response>
    </interface>
    <interface>
      <name>Prisma Client Singleton</name>
      <kind>Database client</kind>
      <signature>export const prisma: PrismaClient</signature>
      <path>src/lib/prisma.ts</path>
      <description>Singleton instance preventing connection exhaustion in development</description>
    </interface>
    <interface>
      <name>User Model</name>
      <kind>Database model</kind>
      <signature>model User { id String @id @default(cuid()), email String @unique, password_hash String, created_at DateTime @default(now()), updated_at DateTime @updatedAt }</signature>
      <path>apps/web/prisma/schema.prisma</path>
    </interface>
  </interfaces>

  <tests>
    <standards>Use Vitest for unit tests with database mocking. Integration tests should verify real database connections and schema synchronization. Test the singleton pattern to ensure no connection exhaustion. Health check endpoint must be tested with both successful and failed connection scenarios.</standards>
    <locations>
      <location>tests/unit/lib/prisma.test.ts</location>
      <location>tests/integration/api/health.test.ts</location>
      <location>tests/unit/models/user.test.ts</location>
    </locations>
    <ideas>
      <idea ac="1">Test Prisma client initialization and singleton pattern</idea>
      <idea ac="2">Test User model CRUD operations with proper field mapping</idea>
      <idea ac="3">Test database connection with various connection strings</idea>
      <idea ac="4">Test prisma generate and db push command execution</idea>
      <idea ac="5">Test health check endpoint with connected and disconnected states</idea>
      <idea ac="all">Test connection pooling behavior under load</idea>
    </ideas>
  </tests>
</story-context>